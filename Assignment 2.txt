Group Members: Victor Pavao, Gavin Scallon, Amy Shin
CSC 1800-001
Klassner
10 November 2017
Assignment 2 – Project Report


Group Roles:
Victor Pavao - Person class, methods, user interface
Gavin Scallon - methods, testing, report
Amy Shin - reviewing and editing


Team Development:
                 The group approached this project with the goal of following the stages outlined in the “Team Development” handout we received in class. We felt by trying to mirror the sequence of events that was outlined in the packet, each member of the group would have a clear idea of their role and responsibility within the team. The “forming” stage was the most helpful. Our group was able to meet up and spell out the requirements that needed to be met for this project. After we had a list of the requirements that needed to be met, it was easy to assign each group member a block of tasks that they were responsible for completing. This ensured we did not have any communication issues regarding who was doing what and when.
                The distinction between the “storming” and “norming” stages were very apparent in our group. When we were first assigned the project, all of the group members were busy with midterms and had to put this assignment on the “back-burner” until right before fall break. Then in the week of fall break and the days after, the communication among the group members was not great. It was difficult for the group to gauge exactly where we were in the project. However, the group met a couple of times and got back on the same page, resolving to be more open with our communication and helping other members if they were having difficulty (this was the “norming” stage). The project’s progress really picked up after this.
                The group wrapped up the project earlier this week and had only this paper left to write. The preparation and communication that the group had over the course of the project was instrumental in its success and prevented us from needing to pull all-nighters around the project deadline to complete it. The team developed into a stronger unit over the course of the project and all group members were supportive and congratulatory of the other members. The group is very prepared and comfortable with each other heading into the next assignment.
 
Project Design/Approach:
Our group decided to build start by creating a Person class. This was similar to the way we had written the project in Java. We could use the class to instantiate Person objects that would be used for any addition to the tree. The constructor took a little research to figure out, especially getting used to the self identifier as the first parameter. We decided to include name, parents, children, and spouses as the parameters (attributes) for a Person. We initialized parents, children, and spouses as empty lists in the constructor, with it in mind that they would be modified and added to. We included the __eq__ method, which functions like the .equals() method when comparing the referential equality of objects in Java.  We chose to use a dictionary to store the family tree. Instead of using conventional getters and setters like in Java, we used a get_person(name) method that searches the dictionary for a Person’s name. We then used this method inside the getter methods for the lists (siblings, and children, parents). And instead of “setting” parents and cousins, like Victor did in the Java assignment, we appended people to the respective lists using the add_person(name) method.
Python provided some functionality not present in Java that improved our code. For example, subtraction and intersection operations on lists improved the readability and efficiency of our code. These features were not available in Java arrays and ArrayList. However, much of the code’s format (e.g. if-else statements) were very similar to Java, so the new syntax was not very difficult to learn. However, there still were differences between Java and Python that provided a source of difficulty for the participants.


Difficulties Faced:
                One of the most difficult aspects of this assignment was coding the assignment in Python. While Victor had previous experience coding in Python from the Bioinformatics course, Gavin and Amy were only vaguely familiar with it. As a result, Victor had to wait a bit for Gavin and Amy to familiarize themselves with the intricacies of Python and study the documentation. Victor used this time well to design the Person Object and start the actual program coding. He also served as a very valuable resource for any questions Gavin and Amy had about Python coding and the differences between Java and Python.
                Another difficulty the group faced was deciding on the approach to the project. Gavin’s Assignment 1 utilized a directed graph to build the family tree and determine family relationships, while Victor and Amy’s programs approached the family tree problem by using arrays. It was decided that Gavin’s approach seemed needlessly complex for this assignment since it was clear that a combination of the Person Object and relationship arrays could be used to build the tree and answer questions. After some research, it was clear Python’s dictionary and list capabilities were more in-line with the array approach.
                Additionally, figuring out how to run the project from the terminal proved more difficult than expected. On its face, this procedure seems simple, but there were a number of steps that the group needed to be taken before this was able to work. Each member of the group has had experience with the command line and the terminal, but not necessarily with running Python in the command line and using one text file as input and another text file as output. 
The project requirements stated that this assignment was to be completed in Python 3.6, so the beginning command needed to be “python3” instead of “python”. Initially, the group mistakenly used “python” for the beginning command (the command for Python 2.7), which resulted in the terminal displaying errors that were not present when the program was run in an IDE (which used Python 3.6). This caused wasted time, as the initial reaction was to try and modify the program to resolve the errors, when the main issue was with the way the file was being run. 
There were a number of times that our group attempted to run the Python script and accidentally overwrote the Python and/or input text file. We were lucky to save extra copies of the program in different locations on our respective computers that saved us when the overwriting occurred.
We also encountered an issue with line spacing in the text output file. Initially, our program was printing out the name or answer to the last W/X question line on the same line as the reprinted original line for all of the test files. In the cases where a series of names were returned, the first name was included on the reprinting of the original line. For example, if the final line was “W unrelated Xerxes” in the input file, the output answer would be printed as:
        “W unrelated XerxesAlbert
         Alberta
         Alex”
        etc.


In the cases where the last line of the input file resulted in an answer, the answer would be printed on the same line as the reprinted input file line. For example, if the final line was “X Fred sibling Xerxes” in the input file, the output answer would be printed as: “X Fred sibling XerxesNo”. We fixed the issue by setting a variable last_line equal to the last line of the input file by scanning the input file and going to the last line using pass. Then, we iterated through the input file again, checking whether the current line was the last line. When this was the case, we used a different function for handling the line (handle_line_2), which utilized blank-space printing in order for the correct output to be printed. This way of handling the issue did result in an extra blank-space between the reprinted last input file line and the response (as detailed below in the Program Evaluation section) for a small number of the test files used.


Testing:
        When we were in the initial stages of writing the program, we tested the Person object and many of the getter and setter methods by creating a “fake” family tree right at the end of the file. These fake family trees were basic (there were only a handful of relationships in each tree) so that we knew right away if there were any names returned that were incorrectly, or if there were any names that we were expecting to be returned that were missing. This allowed us to quickly check our latest code additions for accuracy before moving onto creating the next function or section of the program.         
During the next testing phase, once the majority of the program had been completed, testing was done in the IDE. We chose to do this phase of testing in an IDE to eliminate the possibility that we were not running the terminal command prompts correctly (which actually happened later on, as mentioned above). The test files used during this phase were text files distributed by the professor after the first assignment was submitted. We were able to check the correctness of our program by comparing our program’s output with the correct output files that we were given. 
After testing the program in the IDE and fixing any remaining issues, the final testing phase occurred in the terminal using command line prompts. This phase was done last in order to ensure that our program worked correctly prior to running the script in the terminal. As a result, we knew right away that any issues that arose were due to errors in the command line prompts as opposed to errors in the program. We were then able to resolve these issues quickly. 


Program Evaluation:
                This program is equipped to handle the text files that were used for testing the family tree program from the first assignment. Likewise, the program passed a series of tests the group created on their own in order to see if the program was working correctly. We are confident that the program can handle more than just these test files and would work for most family trees. The program, through its use of lists, does a good job of minimizing the number of operations needed to answer various questions by limiting the search time and operations for determining relationships. This program could potentially be used on trees of scale with the way it has been designed (although we would possibly need to include “with” in obtaining the input file in order to automatically close it after the lines have been iterated through).
        However, our program does have a small spacing issue in the outputs for test files 8, 9, and 10 from the test files given to us from the instructor. The output from the final line of these files contains a whitespace before the first name or answer after the original line is reprinted. This is a small issue for the purposes of this assignment that we decided we would have to live with after spending a few hours attempting to fix it. These spacing issues in tests 8, 9, and 10 came about after implementing our fix for the spacing issues that were occurring with all of the test output files (as detailed at the end of the Difficulties Faced section of this report). This problem does not impact the correctness of the names or answers to the questions in any way.


Overall Reaction
                This assignment was great practice for coding in Python and each group member definitely learned a lot. It was very useful to repeat the first assignment using a different programming language. Solving the same programming problem in a different way meant we were not “lost in the dark” when starting the project, but instead allowed us to focus on creating the new program efficiently (as opposed to using a brute-force method to hammer out a program that worked. Likewise, it was also valuable practice running the program from the terminal and creating a text output file using a language that we were not as experienced with.