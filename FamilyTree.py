#!/usr/bin/python"""Code created by Victor Pavao, Gavin Scallon, and Amy Shin for Assignment 2 ofCSC 1800 course with Prof. Klassner at Villanova University, Fall 2017.This file allows for the construction of a family tree and answers questionsabout the people included in the tree from an input .txt file. The answersto these questions are written to an output .txt file and the program is meantto be executed via command line prompt."""import sysimport fileinputimport osclass Person:    #Constructor    def __init__(self, name, parents):        self.name = name        self.parents = parents        self.children = []        self.spouses = []    #Compares two person objects and determines whether they are equal    def __eq__(self, other):        return self.name == other.name    #Returns string (name) of the person object    def __str__(self):        return self.name# Dictionary to store family treefamily_tree = dict()#General getters and settersdef add_person(person):    if person.name not in family_tree:        family_tree[person.name] = person    return family_tree[person.name]def get_person(name):    if name in family_tree:        return family_tree[name]def get_entire_tree():    return list(family_tree.keys())def get_parents(name):    person = get_person(name)    if person:        return person.parents    else:        return []def get_children(name):    person = get_person(name)    if person:        return person.children    else:        return []def get_spouses(name):    person = get_person(name)    if person:        return person.spouses    else:        return []def get_siblings(name):    sibs = []         person = get_person(name)       #Check to see if person and parents both exist    if person and person.parents:        #Retrieves all the children of parent1, eliminates the name itself in case it appears        parent_1 = get_person(person.parents[0])        parent_1_children = parent_1.children        if name in parent_1_children:            parent_1_children.remove(name)        # Retrieves all the children of parent2, eliminates the name itself in case it appears        parent_2 = get_person(person.parents[1])                parent_2_children = parent_2.children        if name in parent_2_children:            parent_2_children.remove(name)        # Compares the children of the parents and sets the siblings equal to their intersection        sibs = set(parent_1_children).intersection(parent_2_children)    return sibs# Returns a list of a person's half-siblingsdef get_half_siblings(name):    half_sibs = []    person = get_person(name)       # Check to see if person and parents both exist    if person and person.parents:        #Does essentially the first few steps as the normal get_siblings method        parent_1 = get_person(person.parents[0])        parent_1_children = parent_1.children        if name in parent_1_children:            parent_1_children.remove(name)        parent_2 = get_person(person.parents[1])        parent_2_children = parent_2.children        if name in parent_2_children:            parent_2_children.remove(name)        half_sibs.append(parent_1_children)        half_sibs.append(parent_2_children)        half_sibs = set(parent_1_children).symmetric_difference(parent_2_children)    return half_sibs"""Returns a list of all ancestors of a person given their name"""def ancestor_helper(name, ancestor_list):    parents = get_parents(name)    # Adam & Eve generation    if not parents:        ancestor_list.append(name)    else:        ancestor_list.extend(parents)        for parent in parents:            ancestor_helper(parent, ancestor_list)def get_ancestors(name):    ancestor_list = []    ancestor_helper(name, ancestor_list)    return list(set(ancestor_list))"""Returns a list of all descendants of a person given their name"""def get_descendants(name):    descendant_list = []    descendants_helper(name, descendant_list)    return list(set(descendant_list))# Helper method for get_descendantsdef descendants_helper(name, descendant_list):    children = get_children(name)    if not children:        descendant_list.append(name)    else:        descendant_list.extend(children)        for child in children:            descendants_helper(child, descendant_list)"""Returns a list of all relatives of a person given their name"""def get_relatives(name):    relatives = []    ancestors = get_ancestors(name)    relatives.extend(ancestors)    for ancestor in ancestors:        relatives.extend(get_descendants(ancestor))    return list(set(relatives))"""Checks if two given names are cousins"""def get_cousins_helper(person1_name, person2_name):    # Checks if input names are present in tree or the same name, returns false if so    if (not person1_name in family_tree or not person2_name in family_tree):        return False    if (person1_name == person2_name):        return False    index = 0    related_cousins = False    entire_family = get_entire_tree()    # Checks whether the cousin relationship has already been established and adds if not    while (index < len(family_tree) and not related_cousins):        check_name = entire_family[index]        if (check_name in get_ancestors(person1_name) and check_name in get_ancestors(person2_name)):            related_cousins = True        index += 1    return related_cousins"""Obtains the names of everyone in the tree that the input name is cousins with."""def get_cousins(name):    cousins = []    entire_family = get_entire_tree()    for index in entire_family:        if (get_cousins_helper(index, name) and index != name):            cousins.append(index)    #Remove all     cousins = list(set(cousins) - set(get_siblings(name)))    cousins = list(set(cousins) - set(get_descendants(name)))    cousins = list(set(cousins) - set(get_spouses(name)))    cousins = list(set(cousins) - set(get_ancestors(name)))    return list(set(cousins))"""Returns list of all unrelated people"""def get_unrelated(name):    unrelated = get_entire_tree()    # Uses list subtraction on the list of all relatives in the tree    unrelated = list(set(unrelated) - set(get_relatives(name)))    unrelated = list(set(unrelated) - set(get_descendants(name)))    unrelated = list(set(unrelated) - set(get_siblings(name)))    if name in unrelated:        unrelated.remove(name)    return unrelated"""Used to append new additions to dictionary"""def processE(input):    parent1_name = input[1]    parent2_name = input[2]    # Creates Person objects based on the input name of Parents    parent1 = add_person(Person(parent1_name, []))    parent2 = add_person(Person(parent2_name, []))        # Adds the other parent as a spouse if not already there    if parent2.name not in parent1.spouses:        parent1.spouses.append(parent2.name)    if parent1.name not in parent2.spouses:        parent2.spouses.append(parent1.name)    # Check if this event includes a child    if len(input) > 3:        child_name = input[3]        add_person(Person(child_name, [parent1.name, parent2.name]))        parent1.children.append(child_name)        parent2.children.append(child_name)# Prints a sorted listdef print_sorted(unsorted_list):    if unsorted_list:        for x in sorted(unsorted_list):            print(x)"""Returns yes or no depending on whether the input statement is factually correct"""def processX(input_array):    person1_name = input_array[1]    person2_name = input_array[3]    relation = input_array[2]    if relation == "sibling":        if person1_name in get_siblings(person2_name):            print("Yes")        else:            print("No")    elif relation == "half-sibling":        if person1_name in get_half_siblings(person2_name):            print("Yes")        else:            print("No")    elif relation == "relative":        if list(set(get_ancestors(person1_name)) & set(get_ancestors(person2_name))):            print("Yes")        else:            print("No")    elif relation == "spouse":        if person2_name in get_spouses(person1_name):            print("Yes")        else:            print("No")    elif relation == "parent":        if person1_name in get_parents(person2_name):            print("Yes")        else:            print("No")    elif relation == "cousin":        result = get_cousins_helper(person1_name, person2_name)        if result:            print("Yes")        else:            print("No")    elif relation == "ancestor":        if person1_name in get_ancestors(person2_name):            print("Yes")        else:            print("No")    elif relation == "unrelated":        if person1_name in get_unrelated(person2_name):            print("Yes")        elif (not person1_name in family_tree or not person2_name in family_tree):            print("Yes")        else:            print("No")"""Method prints out list of relatives given the relation to a Person"""def processW(input_array):    relation = input_array[1]    name = input_array[2]    if relation == "sibling":        print_sorted(get_siblings(name))    elif relation == "half-sibling":        print_sorted(get_half_siblings(name))    elif relation == "parent":        print_sorted(get_parents(name))    elif relation == "ancestor":        print_sorted(get_ancestors(name))    elif relation == "relative":        print_sorted(get_relatives(name))    elif relation == "spouse":        print_sorted(get_spouses(name))    elif relation == "unrelated":        print_sorted(get_unrelated(name))    elif relation == "cousin":        name = input_array[2]        print_sorted(get_cousins(name))"""Handles user interface for lines that are not the last line"""def handle_line(raw_line):    if raw_line:        input_array = raw_line.split()        if len(input_array) == 0:            print()        elif input_array[0] == 'E':            processE(input_array)        elif input_array[0] == 'X':            print(raw_line, end='')            processX(input_array)            print()        elif input_array[0] == 'W':            print(raw_line, end='')            processW(input_array)            print()"""Handles user interface for last line to resolve spacing issues in output file"""def handle_line_2(raw_line):    if raw_line:        input_array = raw_line.split()        if len(input_array) == 0:            print()        elif input_array[0] == 'E':            processE(input_array)                    elif input_array[0] == 'W':            print(raw_line, end='')            print()            processW(input_array)            print()        elif input_array[0] == 'X':            print(raw_line, end='')            print()            processX(input_array)            print()"""Functions for interacting with the input text file"""# Retrieves the last linelast_line = Nonefor line in fileinput.input():    pass    last_line = line# Iterates through the input text file and selects line-handling option.for line in fileinput.input():    if line == last_line:        handle_line_2(last_line)    else:        handle_line(line)family_tree = dict()